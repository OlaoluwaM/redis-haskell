module Redis.RDB.IntegrationSpec where

-- import Redis.RDB.Data
-- import Redis.RDB.Format
-- import Test.Hspec
-- import Test.Hspec.Hedgehog

-- import Hedgehog qualified as H
-- import Redis.RDB.Binary qualified as Binary

-- import Control.Exception (SomeException, try)
-- import Data.Foldable (for_)
-- import Data.Time.Clock.POSIX (POSIXTime, getPOSIXTime)
-- import Path
-- import Redis.Helper (encodeThenDecodeRDBBinary)
-- import Redis.RDB.Config (RDBConfig (..))
-- import Redis.RDB.TestConfig (defaultRDBConfig, genRDBConfig)
-- import Refined.Unsafe (reallyUnsafeRefine)
-- import System.Directory (doesFileExist)

-- -- See the top comment in Redis.RDB.Format on why we use `reallyUnsafeRefine` instead of `refineTH` for constants

-- createSampleRDBStructure :: POSIXTime -> RDBFile
-- createSampleRDBStructure currentTime =
--     RDBFile
--         { magicString = Redis
--         , version = RDBv7
--         , auxFieldEntries =
--             [ AuxFieldRedisVer $ RedisVersion $ reallyUnsafeRefine "7.0.0"
--             , AuxFieldRedisBits RedisBits64
--             , AuxFieldCustom (toRDBStringOrIntVal "custom-key") (toRDBStringOrIntVal "custom-value")
--             , AuxFieldCTime $ CTime (fromPosixTimeToRDBUnixTimestampS currentTime)
--             , AuxFieldCustom (toRDBStringOrIntVal "another-key") (toRDBStringOrIntVal "another-value")
--             , AuxFieldUsedMem $ UsedMem 1048576 -- 1MB
--             ]
--         , dbEntries =
--             [ RDbEntry
--                 { entryId = SelectDB (reallyUnsafeRefine 0) -- Database 0
--                 , resizeDBEntry = ResizeDB 4 3 -- 4 keys total, 3 with expiry
--                 , keyValEntries =
--                     [ FCOpCode $
--                         KeyValWithExpiryInMS
--                             { expiryTimeMs = fromPosixTimeToRDBUnixTimestampMS $ currentTime + 300 -- Expires in 5 minutes
--                             , valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "key1"
--                             , encodedValue = toRDBStringOrIntVal "Hello World"
--                             }
--                     , FDOpcode $
--                         KeyValWithExpiryInS
--                             { expiryTimeS = fromPosixTimeToRDBUnixTimestampS $ currentTime + 3600 -- Expires in 1 hour
--                             , valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "counter"
--                             , encodedValue = toRDBStringOrIntVal "42"
--                             }
--                     , FCOpCode $
--                         KeyValWithExpiryInMS
--                             { expiryTimeMs = fromPosixTimeToRDBUnixTimestampMS $ currentTime + 1800 -- Expires in 30 minutes
--                             , valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "123"
--                             , encodedValue = toRDBStringOrIntVal "John Doe"
--                             }
--                     , KeyValOpCode $
--                         KeyValWithNoExpiryInfo
--                             { valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "-439284723"
--                             , encodedValue = toRDBStringOrIntVal "Negative 32 bit integer"
--                             }
--                     ]
--                 }
--             ]
--         }

-- emptyRDBFile :: RDBFile
-- emptyRDBFile =
--     RDBFile
--         { magicString = Redis
--         , version = RDBv7
--         , auxFieldEntries = []
--         , dbEntries = []
--         }

-- rdbFileWithOnlyAuxFields :: RDBFile
-- rdbFileWithOnlyAuxFields =
--     RDBFile
--         { magicString = Redis
--         , version = RDBv7
--         , auxFieldEntries =
--             [ AuxFieldRedisVer . RedisVersion . reallyUnsafeRefine $ "7.2.0"
--             , AuxFieldRedisBits RedisBits64
--             , AuxFieldUsedMem $ UsedMem 2048
--             ]
--         , dbEntries = []
--         }

-- multiDatabaseRDBStructure :: RDBFile
-- multiDatabaseRDBStructure =
--     RDBFile
--         { magicString = Redis
--         , version = RDBv7
--         , auxFieldEntries = []
--         , dbEntries =
--             [ RDbEntry
--                 { entryId = SelectDB (reallyUnsafeRefine 0)
--                 , resizeDBEntry = ResizeDB 1 0
--                 , keyValEntries =
--                     [ KeyValOpCode $
--                         KeyValWithNoExpiryInfo
--                             { valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "db0_key"
--                             , encodedValue = toRDBStringOrIntVal "db0_value"
--                             }
--                     ]
--                 }
--             , RDbEntry
--                 { entryId = SelectDB 1
--                 , resizeDBEntry = ResizeDB 1 0
--                 , keyValEntries =
--                     [ KeyValOpCode $
--                         KeyValWithNoExpiryInfo
--                             { valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "db1_key"
--                             , encodedValue = toRDBStringOrIntVal "db1_value"
--                             }
--                     ]
--                 }
--             , RDbEntry
--                 { entryId = SelectDB 2
--                 , resizeDBEntry = ResizeDB 1 0
--                 , keyValEntries =
--                     [ KeyValOpCode $
--                         KeyValWithNoExpiryInfo
--                             { valueType = Str
--                             , encodedKey = toRDBStringOrIntVal "db2_key"
--                             , encodedValue = toRDBStringOrIntVal "db2_value"
--                             }
--                     ]
--                 }
--             ]
--         }

-- -- | List of example RDB files to test
-- exampleRDBFiles :: [String]
-- exampleRDBFiles =
--     [ "rdb_version_5_with_checksum.rdb"
--     , "empty_database.rdb"
--     , "expiration.rdb"
--     , "integer_keys.rdb"
--     , "keys_with_expiry.rdb"
--     , "multiple_databases.rdb"
--     , "non_ascii_values.rdb"
--     , "easily_compressible_string_key.rdb"
--     ]

-- spec_RDB_integration_tests :: Spec
-- spec_RDB_integration_tests = do
--     describe "RDB File Integration Tests" $ do
--         describe "RDB Creation and Roundtrip Tests" $ do
--             it "Encodes/decodes a sample RDB file successfully (without checksum)" $ do
--                 currentTime <- getPOSIXTime
--                 let rdbStructure = createSampleRDBStructure currentTime
--                 let rdbConfig = defaultRDBConfig{generateChecksum = False, skipChecksumValidation = True}
--                 encodeThenDecodeRDBBinary rdbConfig rdbStructure `shouldBe` rdbStructure

--             it "Encodes/decodes a sample RDB file successfully (with checksum)" $ do
--                 currentTime <- getPOSIXTime
--                 let rdbStructure = createSampleRDBStructure currentTime
--                 let rdbConfig = defaultRDBConfig{generateChecksum = True, skipChecksumValidation = False}
--                 let encoded = Binary.encode rdbConfig rdbStructure
--                 let decoded = Binary.decode @RDBFile rdbConfig encoded

--                 decoded `shouldBe` rdbStructure

--             it "Encodes/decodes an empty RDB file successfully" $ hedgehog $ do
--                 rdbConfig <- H.forAll genRDBConfig
--                 evalIO $ encodeThenDecodeRDBBinary rdbConfig emptyRDBFile `shouldBe` emptyRDBFile

--             it "Encodes/decodes an auxiliary-only RDB file successfully" $ hedgehog $ do
--                 rdbConfig <- H.forAll genRDBConfig
--                 evalIO $ encodeThenDecodeRDBBinary rdbConfig rdbFileWithOnlyAuxFields `shouldBe` rdbFileWithOnlyAuxFields

--             it "handles multiple databases correctly" $ hedgehog $ do
--                 rdbConfig <- H.forAll genRDBConfig
--                 evalIO $ encodeThenDecodeRDBBinary rdbConfig multiDatabaseRDBStructure `shouldBe` multiDatabaseRDBStructure

--             it "encodes large RDB files efficiently" $ hedgehog $ do
--                 currentTime <- evalIO getPOSIXTime
--                 let largeRDB = createLargeRDB currentTime
--                 rdbConfig <- H.forAll genRDBConfig
--                 evalIO $ encodeThenDecodeRDBBinary rdbConfig largeRDB `shouldBe` largeRDB

--         describe "Decoding sample RDB Files" $ do
--             for_ exampleRDBFiles $ \rawTestFilename -> do
--                 it ("successfully decodes " <> rawTestFilename) $ do
--                     testFilename <- parseRelFile rawTestFilename
--                     let filepath = [reldir|test/input/example-rdb-files|] </> testFilename
--                     fileExists <- doesFileExist (toFilePath filepath)
--                     let rdbConfig =
--                             defaultRDBConfig
--                                 { useLzfCompression = True
--                                 , skipChecksumValidation = False
--                                 , generateChecksum = True
--                                 }

--                     if fileExists
--                         then do
--                             result <- try (Binary.decodeFile rdbConfig (toFilePath filepath)) :: IO (Either SomeException RDBFile)
--                             case result of
--                                 Left err -> expectationFailure $ "Failed to decode " <> show filepath <> ": " <> show err
--                                 Right decodedRDB -> do
--                                     decodedRDB.magicString `shouldBe` Redis
--                                     decodedRDB.version `shouldSatisfy` (`elem` [minBound .. maxBound])
--                         else expectationFailure $ "File not found: " <> show filepath

-- -- | Create a large RDB for performance testing
-- createLargeRDB :: POSIXTime -> RDBFile
-- createLargeRDB currentTime =
--     RDBFile
--         { magicString = Redis
--         , version = RDBv7
--         , auxFieldEntries =
--             [ AuxFieldRedisVer . RedisVersion . reallyUnsafeRefine $ "7.0.0"
--             , AuxFieldRedisBits RedisBits64
--             ]
--         , dbEntries =
--             [ RDbEntry
--                 { entryId = SelectDB 0
--                 , resizeDBEntry = ResizeDB 50 25 -- 50 keys, 25 with expiry
--                 , keyValEntries = generateLargeKeyValList currentTime 50
--                 }
--             ]
--         }

-- -- | Generate a large list of key-value entries
-- generateLargeKeyValList :: POSIXTime -> Int -> [KeyValueOpCode]
-- generateLargeKeyValList currentTime count =
--     take count $
--         cycle
--             [ KeyValOpCode $
--                 KeyValWithNoExpiryInfo
--                     { valueType = Str
--                     , encodedKey = toRDBStringOrIntVal "persistent_key"
--                     , encodedValue = toRDBStringOrIntVal "persistent_value"
--                     }
--             , FCOpCode $
--                 KeyValWithExpiryInMS
--                     { expiryTimeMs = fromPosixTimeToRDBUnixTimestampMS $ currentTime + 3600
--                     , valueType = Str
--                     , encodedKey = toRDBStringOrIntVal "expiring_key_ms"
--                     , encodedValue = toRDBStringOrIntVal "expiring_value_ms"
--                     }
--             , FDOpcode $
--                 KeyValWithExpiryInS
--                     { expiryTimeS = fromPosixTimeToRDBUnixTimestampS $ currentTime + 7200
--                     , valueType = Str
--                     , encodedKey = toRDBStringOrIntVal "expiring_key_s"
--                     , encodedValue = toRDBStringOrIntVal "expiring_value_s"
--                     }
--             ]
